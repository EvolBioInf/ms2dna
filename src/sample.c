/***** sample.c **************************************
 * Description: Functions for manipulating a sample
 *   generated by Hudson's ms program.
 * Reference: Hudson, R. R. (2002). Generating samples
 *   under a Wright-Fisher neutral model of genetic 
 *   variation. Bioinformatics 18: 337-338.
 * Author: Bernhard Haubold, haubold@evolbio.mpg.de
 * Date: Tue Aug 14 20:35:23 2007.
 * License: GNU General Public
 *****************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <unistd.h>
#include <fcntl.h>
#include "eprintf.h"
#include "interface.h"
#include "sample.h"
#include "ran.h"
#include "sequence_data.h"
#include "stringUtil.h"

#define MAXLEN 1000

Sample *sample;
Args *args;
FILE *fp;
int sampleCounter;

void expandSample();

int comp(const void *v1, const void *v2){
  return (*(int *)v1 - *(int *)v2);
}


Sample *initializeSample(FILE *filePointer, Args *arguments){
  char *token;
  int i;

  args = arguments;
  fp = filePointer;
  sampleCounter = 0;
  
  sample = (Sample *)emalloc(sizeof(Sample));
  sample->line = (char *)emalloc((MAXLEN+1) * sizeof(char));
  sample->line[0] = '\0';
  /* get first line of input; this contains the command with which ms was started */
  sample->line = fgets(sample->line, MAXLEN, fp);
  token = strtok(sample->line, " ");
  token = strtok(NULL, " ");
  sample->nsam = atoi(token);
  token = strtok(NULL, " ");
  sample->howmany = atoi(token);
  sample->nsite = 0;
  sample->npop = 1;
  sample->sampleSizes = NULL;
  while((token = strtok(NULL, " ")) != NULL){
    if(strcmp(token, "-r") == 0){
      token = strtok(NULL, " ");
      token = strtok(NULL, " ");
      sample->nsite = atoi(token);
    }else if(strcmp(token, "-I") == 0){
      token = strtok(NULL, " ");
      sample->npop = atoi(token);
      sample->sampleSizes = (int *)emalloc(sample->npop*sizeof(int));
      for(i=0;i<sample->npop;i++){
	token = strtok(NULL, " ");
	sample->sampleSizes[i] = atoi(token);
      }
    }
  }
  if(sample->nsite == 0){
    fprintf(stderr,"ERROR [sample.c]: please use ms with the -r switch.\n");
    exit(-1);
  }
  sample->seq = (char **)emalloc(2 * sizeof(char *));
  sample->seq[0] = (char *)emalloc((sample->nsite + 1) * sizeof(char));
  sample->seq[1] = (char *)emalloc((sample->nsite + 1) * sizeof(char));
  sample->maxlen = 1;
  sample->segsites = 0;
  sample->haplotypes = (char **)emalloc((sample->nsam + 1)*sizeof(char *));
  for(i=0;i<sample->nsam;i++){
    sample->haplotypes[i] = (char *)emalloc((sample->maxlen + 1)*sizeof(char));
  }
  sample->map = (int *)emalloc(sample->maxlen * sizeof(int));
  sample->positions = (float *)emalloc(sample->maxlen*sizeof(float));

  return sample;
}

/* getSample: read a haplotype sample from a file pointer assumed to be open */
Sample *getSample(){
  int i;
  char *dum;
  double r1, r2;

  dum = emalloc(250*sizeof(char));
  while(fgets(sample->line,MAXLEN,fp) != NULL){
    if(sample->line[0] == 's'){
      sscanf(sample->line, "segsites: %d", &sample->segsites);
      if(sample->segsites >= sample->maxlen){
	sample->maxlen = sample->segsites+1;
	expandSample(sample);
      }
      if(!fscanf(fp,"%s",dum)){
	printf("ERROR[sample.getSample()]: Cannot read seed for random number generator from file.\n");
	exit(-1);
      }
      if(sample->segsites > 0){
	for(i=0;i<sample->segsites;i++)
	  if(!fscanf(fp, "%f", sample->positions + i))
	    printf("WARNING[smple.getSample()]-1: Something is wrong with reading the sample.\n");
	/* generate extra significant digits for ms output, as ms only generates 4 */
	for(i=0;i<sample->segsites;i++){
	  r1 = genrand_real1();
	  r2 = genrand_real1();
	  r2 /= 10000;
	  if(r1>0.5 && sample->positions[i] - r2 >= 0)
	    sample->positions[i] -= r2;
	  else if(sample->positions[i] + r2 <= 1.0)
	    sample->positions[i] += r2;
	}
	for(i=0;i<sample->nsam;i++){
	  if(!fscanf(fp," %s",sample->haplotypes[i]))
	    printf("WARNING[smple.getSample()]-2: Something is wrong with reading the sample.\n");
	}
      }
      free(dum);
      return sample;
    }
  }
  free(dum);
  return NULL;
}

void outputSample(FILE *fpo){
  int i;
  double r1, r2;
  int p;
  char nuc;

  /* generate ancestral sequence */
  for(i=0;i<sample->nsite;i++){
    r1 = genrand_real1();
    r2 = genrand_real1();
    if(r1 <= args->g){
      if(r2 <= 0.5)
	sample->seq[0][i] = 'G';
      else
	sample->seq[0][i] = 'C';
    }else{
      if(r2 <= 0.5)
	sample->seq[0][i] = 'A';
      else
	sample->seq[0][i] = 'T';
    }
  }
  for(i=0;i<sample->nsite;i++)
    sample->seq[1][i] = 'x';
  if(sample->segsites > sample->nsite){
    printf("#WARNING: number of segregating sites (%d) > number of mutable sites (%d)\n",sample->segsites,sample->nsite);
    printf("#Are you dealing with macs input? If so, please use the -a option.\n");
  }
  /* map segregating sites onto sequence positions */
  for(i=0;i<sample->segsites;i++){
    p = sample->positions[i] * sample->nsite;
    while(sample->seq[1][p] != 'x') /* check for double hits */
      p = genrand_real1() * sample->nsite;
    sample->map[i] = p;
    sample->seq[1][p] = 'y';
  }
  /* map the last segregating site to nonsense */
  sample->map[sample->segsites] = -1;
  /* generate nucleotides for mutant positions */
  for(i=0;i<sample->segsites;i++){
    r1 = genrand_real1();
    r2 = genrand_real1();
    p = sample->map[i];
    if(r1 <= args->g){                    /* is the derived state G/C? */
      if(sample->seq[0][p] == 'G')          /* is the ancestral state G? */
	nuc = 'C';                            /* mutate to C */
      else if(sample->seq[0][p] == 'C')     /* is the ancestral state C? */
	nuc = 'G';                            /* mutate to G */
      else                                  /* is the ancestral state A/T? */
	if(r2 <= 0.5)                         /* draw equiprobable G or C */
	  nuc = 'G';
	else
	  nuc = 'C';
    }else{                                /* is the derived state A/T? */
      if(sample->seq[0][p] == 'A')          /* is the ancestral state A? */
	nuc = 'T';                            /* mutate to T */
      else if(sample->seq[0][p] == 'T')     /* is the ancestral state T? */
	nuc = 'A';                            /* mutate to A */
      else                                  /* is the ancestral state G/C? */
	if(r2 <= 0.5)                         /* draw equiprobable A or T */
	  nuc = 'A';
	else
	  nuc = 'T';
    }
    sample->seq[1][p] = nuc;
  }
  sampleCounter++;
  printFasta(fpo);
}

void printFasta(FILE *fpo){
  int ns;  /* segregating sites counter */
  int nc;  /* nucleotide counter */
  int sc;  /* sequence counter (within population) */
  int pc;  /* population counter */
  int i, j;
  int lineLen;

  lineLen = 70;
  nc = 0;
  sc = 0;
  pc = 0;
  for(i=0;i<sample->nsam;i++){
    fprintf(fpo,">");
    if(sample->howmany > 1)
      fprintf(fpo,"L%d",sampleCounter);
    if(sample->npop > 1){
      if(sample->nsam > 1)
	fprintf(fpo,"_P%d",pc+1);
      else
	fprintf(fpo,"P%d",pc+1);
    }
    if(sample->npop > 1 || sample->howmany > 1)
      fprintf(fpo,"_S%d\n",++sc);
    else
      fprintf(fpo,"S%d\n",++sc);
    if(sample->npop > 1){
      if(sc == sample->sampleSizes[pc]){
	sc = 0;
	pc++;
      }
    }
    /* print haplotype */
    nc = 0;
    ns = 0;
    qsort(sample->map,sample->segsites,sizeof(int),comp);
    for(j=0;j<sample->nsite;j++){
      if(ns >= sample->maxlen)
	printf("ns: %d; sample->maxlen: %d\n",ns,sample->maxlen);
      if(j == sample->map[ns]){ /* mutant position */
	if(sample->haplotypes[i][ns] == '1') /* print derived nucleotide */
	  fprintf(fpo,"%c",sample->seq[1][j]);
	else                                 /* print ancestral nucleotide */
	  fprintf(fpo,"%c",sample->seq[0][j]);
	ns++;
      }else
	fprintf(fpo,"%c",sample->seq[0][j]);
      nc++;
      if(nc == lineLen && j < sample->nsite - 1){
	fprintf(fpo,"\n");
	nc = 0;
      }
    }
/*     if(nc != lineLen) */
    fprintf(fpo,"\n");
  }
}

/* increase space for individual haplotypes
 */
void expandSample(){
  int i;

  for(i=0;i<sample->nsam;i++)
    sample->haplotypes[i] = (char *)erealloc(sample->haplotypes[i],sample->maxlen*sizeof(char));
  sample->map = (int *)erealloc(sample->map,sample->maxlen*sizeof(int));
  sample->positions = (float *)erealloc(sample->positions,sample->maxlen*sizeof(float));
  
}

/* freeSample: clean up after run of program:
 * 1) free memory
 * 2) update seed for random number generator
 */
void freeSample(){
  for(int i=0;i<sample->nsam;i++)
    free(sample->haplotypes[i]);
  free(sample->haplotypes);
  free(sample->positions);
  free(sample->map);
  free(sample->seq[0]);
  free(sample->seq[1]);
  free(sample->seq);
  if(sample->sampleSizes)
    free(sample->sampleSizes);
  free(sample->line);
  free(sample);
}
